# basic-file-exploit

## Description

The program provided allows you to write to a file and read what you wrote from it. Try playing around with it and see if you can break it! Connect to the program with netcat: `$ nc saturn.picoctf.net 52682` The program's source code with the flag redacted can be downloaded [here](https://artifacts.picoctf.net/c/537/program-redacted.c).

Challenge [link](https://play.picoctf.org/practice/challenge/252?originalEvent=70&page=1)

## Getting Started

To start we'll connect to the server and download the source code.

### Connecting to the server

We run the netcat command given to us and are presented with 3 options:

```
$ nc saturn.picoctf.net 52682
Hi, welcome to my echo chamber!
Type '1' to enter a phrase into our database
Type '2' to echo a phrase in our database
Type '3' to exit the program
```
#### Option 1

Allows entry of data to the server:

```
1
1
Please enter your data:
test
test
Please enter the length of your data:
5
5
Your entry number is: 1
Write successful, would you like to do anything else?
```

#### Option 2

Allows our previously entered data to be read from the server:
```
2
2
Please enter the entry number of your data:
1
1
test
Read successful, would you like to do anything else?
```

#### Option 3

Allows us to exit from the program:
```
3
3

$
```

### Source code

Using wget we download the source code:

`wget https://artifacts.picoctf.net/c/537/program-redacted.c`

We then open this in a text editor of our choice.

It's worth noting at this point I'm no developer. Although I ~~can~~ code it's primarily in bash and python as my day job is more to do with IaaS than developing applications. C is not a language I'm particularly familiar with so apologies to anyone knowlegeable in the language.

Initially we see several include statements, the import common c libraries that the application uses. We can see after this the flag variable is defined `static const char* flag = "[REDACTED]";`

If we search for where this flag is variable is called, we see its contained within the data_read function:

```c
static void data_read() {
  char entry[4];
  long entry_number;
  char output[100];
  int r;

  memset(output, '\0', 100);
  
  printf("Please enter the entry number of your data:\n");
  r = tgetinput(entry, 4);
  // Timeout on user input
  if(r == -3)
  {
    printf("Goodbye!\n");
    exit(0);
  }
  
  if ((entry_number = strtol(entry, NULL, 10)) == 0) {
    puts(flag);
    fseek(stdin, 0, SEEK_END);
    exit(0);
  }

  entry_number--;
  strncpy(output, data[entry_number], input_lengths[entry_number]);
  puts(output);
}

```

So we need to check what calls the data_read function, this is within the main code
```c
int main(int argc, char** argv) {
  char input[3] = {'\0'};
  long command;
  int r;

  puts("Hi, welcome to my echo chamber!");
  puts("Type '1' to enter a phrase into our database");
  puts("Type '2' to echo a phrase in our database");
  puts("Type '3' to exit the program");

  while (true) {   
    r = tgetinput(input, 3);
    // Timeout on user input
    if(r == -3)
    {
      printf("Goodbye!\n");
      exit(0);
    }
    
    if ((command = strtol(input, NULL, 10)) == 0) {
      puts("Please put in a valid number");
    } else if (command == 1) {
      data_write();
      puts("Write successful, would you like to do anything else?");
    } else if (command == 2) {
      if (inputs == 0) {
        puts("No data yet");
        continue;
      }
      data_read();
      puts("Read successful, would you like to do anything else?");
    } else if (command == 3) {
      return 0;
    } else {
      puts("Please type either 1, 2 or 3");
      puts("Maybe breaking boundaries elsewhere will be helpful");
    }
  }

  return 0;
}
```

We can see that data_read function is called when you select option 2 `else if (command == 2) {` however there is a secondary check to validate that data is stored within the database.
```c       
if (inputs == 0) {
   puts("No data yet");
   continue;
```
This is added to as part of option 1
```c
printf("Your entry number is: %d\n", inputs + 1);
  inputs++
```

So we know that before reading data we must first enter data. We'll keep that in mind when we connect to the real service.

In order to get the flag printed we must access this part of the data_read() function:

```c
  if ((entry_number = strtol(entry, NULL, 10)) == 0) {
    puts(flag);
    fseek(stdin, 0, SEEK_END);
    exit(0);
  }

  entry_number--;
  strncpy(output, data[entry_number], input_lengths[entry_number]);
  puts(output);

```

So what is this doing, well the part of the function before this captures the entry the user would like to read. `strtol` converts a string to a long integer with the option of specifying this is in base 10. If what we enter compares to equal 0 the the flag variable is `puts`  writes the string s and a trailing newline to stdout.

So in order to get the flag we must enter 0 as the data_read entry option.

### Solution

So lets try this, we connect and enter 2 to read

```
$ nc saturn.picoctf.net 52682
Hi, welcome to my echo chamber!
Type '1' to enter a phrase into our database
Type '2' to echo a phrase in our database
Type '3' to exit the program
2
2
No data yet
```
Not what we had in mind but if we remember earlier in our source code *"So we know that before reading data we must first enter data. We'll keep that in mind when we connect to the real service.
"* This time we'll enter a piece of data first and then try to read data from entry 0.
```
$ nc saturn.picoctf.net 52682
Hi, welcome to my echo chamber!
Type '1' to enter a phrase into our database
Type '2' to echo a phrase in our database
Type '3' to exit the program
1
1
Please enter your data:
testing
testing
Please enter the length of your data:
7
7
Your entry number is: 1
Write successful, would you like to do anything else?
2
2
Please enter the entry number of your data:
0
0
picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_038A9E95}
```
And we got it.

## Authors

jimjamg
